#!/usr/bin/env python

import time
start_imports = time.time()

import sys, os, argparse, re
import subprocess
from copy import deepcopy
import json

import numpy as np
import fitsio
from astropy.io import fits
import glob
import desiutil.timer
import desispec.io
from desispec.io import findfile
from desispec.io.util import create_camword
from desispec.calibfinder import findcalibfile,CalibFinder
from desispec.fiberflat import apply_fiberflat
from desispec.sky import subtract_sky
from desispec.util import runcmd
import desispec.scripts.extract
import desispec.scripts.specex

from desitarget.targetmask import desi_mask

from desiutil.log import get_logger, DEBUG, INFO
stop_imports = time.time()

from desispec.workflow.desi_proc_funcs import get_desi_proc_joint_fit_parser, create_desi_proc_batch_script
from desispec.workflow.desi_proc_funcs import update_args_with_headers

parser = get_desi_proc_joint_fit_parser()
args = parser.parse_args()
log = get_logger()



if args.mpi and not args.batch:
    from mpi4py import MPI

    comm = MPI.COMM_WORLD
    rank = comm.rank
    size = comm.size
else:
    comm = None
    rank = 0
    size = 1

#- Prevent MPI from killing off spawned processes
if 'PMI_MMAP_SYNC_WAIT_TIME' not in os.environ:
    os.environ['PMI_MMAP_SYNC_WAIT_TIME'] = '3600'

#- Double check env for MPI+multiprocessing at NERSC
if 'MPICH_GNI_FORK_MODE' not in os.environ:
    os.environ['MPICH_GNI_FORK_MODE'] = 'FULLCOPY'
    if rank == 0:
        log.info('Setting MPICH_GNI_FORK_MODE=FULLCOPY for MPI+multiprocessing')
elif os.environ['MPICH_GNI_FORK_MODE'] != 'FULLCOPY':
    gnifork = os.environ['MPICH_GNI_FORK_MODE']
    if rank == 0:
        log.error(f'MPICH_GNI_FORK_MODE={gnifork} is not "FULLCOPY"; this might not work with MPI+multiprocessing, but not overriding')
elif rank == 0:
    log.debug('MPICH_GNI_FORK_MODE={}'.format(os.environ['MPICH_GNI_FORK_MODE']))

#- Start timer; only print log messages from rank 0 (others are silent)
timer = desiutil.timer.Timer(silent=(rank>0))

#- Start timer; only print log messages from rank 0 (others are silent)
timer = desiutil.timer.Timer(silent=(rank>0))
if args.starttime is not None:
    timer.start('startup', starttime=args.starttime)
    timer.stop('startup', stoptime=start_imports)

timer.start('imports', starttime=start_imports)
timer.stop('imports', stoptime=stop_imports)

#- Freeze IERS after parsing args so that it doesn't bother if only --help
timer.start('freeze_iers')
import desiutil.iers
desiutil.iers.freeze_iers()
timer.stop('freeze_iers')

#- Preflight checks
timer.start('preflight')

# - Preflight checks
if rank > 0:
    # - Let rank 0 fetch these, and then broadcast
    args = None
else:
    cam_str = args.cameras.strip(' \t').lower()
    cameras = cam_str.split(',')
    if cam_str[0] not in ['b', 'r', 'z'] and cameras[0].isnumeric():
        args.cameras = []
        for camnum in cameras:
            for ccd in ['b', 'r', 'z']:
                args.cameras.append('{}{}'.format(ccd, camnum))
    else:
        args.cameras = cameras

    args.expids = np.array(args.expids.strip(' \t').split(',')).astype(int)
    #args.nights = np.array(args.nights.strip(' \t').split(',')).astype(int)
    args.night = int(args.night)
    #if len(args.expids) > len(args.nights) and len(args.nights) == 1:
    #    args.nights = np.array([args.nights[0]] * len(args.expids)).astype(int)

    # - Update args to be in consistent format
    if args.batch_opts is not None:
        args.batch_opts = args.batch_opts.strip('"\'')
    args.cameras = sorted(args.cameras)
    args.obstype = args.obstype.upper()

if comm is not None:
    args = comm.bcast(args, root=0)

known_obstype = ['SCIENCE', 'ARC', 'FLAT']
if args.obstype not in known_obstype:
    raise RuntimeError('obstype {} not in {}'.format(args.obstype, known_obstype))


timer.stop('preflight')


# -------------------------------------------------------------------------
# - Create and submit a batch job if requested

if args.batch:
    #camword = create_camword(args.cameras)
    #exp_str = '-'.join('{:08d}'.format(expid) for expid in args.expids)
    if args.obstype.lower() == 'science':
        jobdesc = 'stdstarfit'
    elif args.obstype.lower() == 'arc':
        jobdesc = 'psfnight'
    elif args.obstype.lower() == 'flat':
        jobdesc = 'nightlyflat'
    else:
        jobdesc = args.obstype.lower()
    scriptfile = create_desi_proc_batch_script(night=args.night, exp=args.expids, cameras=args.cameras,\
                                               jobdesc=jobdesc, queue=args.queue, runtime=args.runtime,\
                                               batch_opts=args.batch_opts, timingfile=args.timingfile)
    err = 0
    if not args.nosubmit:
        err = subprocess.call(['sbatch', scriptfile])
    sys.exit(err)

# -------------------------------------------------------------------------
# - Proceed with running

# - What are we going to do?
if rank == 0:
    log.info('----------')
    log.info('Input {}'.format(args.inputs))
    log.info('Night {} expids {}'.format(args.night, args.expids))
    log.info('Obstype {}'.format(args.obstype))
    log.info('Cameras {}'.format(args.cameras))
    log.info('Output root {}'.format(desispec.io.specprod_root()))
    log.info('----------')

# - Wait for rank 0 to make directories before proceeding
if comm is not None:
    comm.barrier()

# -------------------------------------------------------------------------
# - Merge PSF of night if applicable

if args.obstype in ['ARC']:
    timer.start('psfnight')
    if rank == 0:
        for camera in args.cameras:
            psfnightfile = findfile('psfnight', args.night, args.expids[0], camera)
            if not os.path.isfile(psfnightfile):  # we still don't have a psf night, see if we can compute it ...
                psfs = [findfile('psf', args.night, expid, camera).replace("psf", "fit-psf") for expid in args.expids]
                log.info("Number of PSF for night={} camera={} = {}".format(args.night, camera, len(psfs)))
                if len(psfs) > 4:  # lets do it!
                    log.info("Computing psfnight ...")
                    dirname = os.path.dirname(psfnightfile)
                    if not os.path.isdir(dirname):
                        os.makedirs(dirname)
                    desispec.scripts.specex.mean_psf(psfs, psfnightfile)
                else:
                    log.info("Fewer than 4 psfs were provided, can't compute psfnight. Exiting ...")


    timer.stop('psfnight')


                    
# -------------------------------------------------------------------------
# - Average and auto-calib fiberflats of night if applicable

if args.obstype in ['FLAT']:
    timer.start('fiberflatnight')
    if rank == 0:
        fiberflatnightfile = findfile('fiberflatnight', args.night, args.expids[0], args.cameras[0])
        fiberflatdirname = os.path.dirname(fiberflatnightfile)
        if os.path.isfile(fiberflatnightfile):
            log.info("Fiberflatnight already exists. Exitting ...")
        elif len(args.cameras) < 6:  # we still don't have them, see if we can compute them
            # , but need at least 2 spectros ...
            log.info("Fewer than 6 cameras were available, so couldn't perform joint fit. Exiting ...")
        else:
            flats = []
            for camera in args.cameras:
                for expid in args.expids:
                    flats.append(findfile('fiberflat', args.night, expid, camera))
            log.info("Number of fiberflat for night {} = {}".format(args.night, len(flats)))
            if len(flats) < 3 * 4 * len(args.cameras):
                log.info("Fewer than 3 exposures with 4 lamps were available. Can't perform joint fit. Exiting...")
            else:
                log.info("Computing fiberflatnight per lamp and camera ...")
                tmpdir = os.path.join(fiberflatdirname, "tmp")
                if not os.path.isdir(tmpdir):
                    os.makedirs(tmpdir)
                            
                log.info("First average measurements per camera and per lamp")
                average_flats = dict()
                for camera in args.cameras:
                    # list of flats for this camera
                    flats_for_this_camera = []
                    for flat in flats:
                        if flat.find(camera) >= 0:
                            flats_for_this_camera.append(flat)
                    # log.info("For camera {} , flats = {}".format(camera,flats_for_this_camera))
                    # sys.exit(12)
                                        
                    # average per lamp (and camera)
                    average_flats[camera] = list()
                    for lampbox in range(4):
                        ofile = os.path.join(tmpdir, "fiberflatnight-camera-{}-lamp-{}.fits".format(camera, lampbox))
                        if not os.path.isfile(ofile):
                            log.info("Average flat for camera {} and lamp box #{}".format(camera, lampbox))
                            pg = "CALIB DESI-CALIB-0{} LEDs only".format(lampbox)

                            cmd = "desi_average_fiberflat --program '{}' --outfile {} -i ".format(pg, ofile)
                            for flat in flats_for_this_camera:
                                cmd += " {} ".format(flat)
                            runcmd(cmd, inputs=flats_for_this_camera, outputs=[ofile, ])
                            if os.path.isfile(ofile):
                                average_flats[camera].append(ofile)
                            else:
                                log.info("Will use existing {}".format(ofile))
                                average_flats[camera].append(ofile)

                log.info("Auto-calibration across lamps and spectro  per camera arm (b,r,z)")
                for camera_arm in ["b", "r", "z"]:
                    cameras_for_this_arm = []
                    flats_for_this_arm = []
                    for camera in args.cameras:
                        if camera[0].lower() == camera_arm:
                            cameras_for_this_arm.append(camera)
                            if camera in average_flats:
                                for flat in average_flats[camera]:
                                    flats_for_this_arm.append(flat)
                    cmd = "desi_autocalib_fiberflat --night {} --arm {} -i ".format(args.night, camera_arm)
                    for flat in flats_for_this_arm:
                        cmd += " {} ".format(flat)
                    runcmd(cmd, inputs=flats_for_this_arm, outputs=[])
                log.info("Done with fiber flats per night")

    timer.stop('fiberflatnight')  
    if comm is not None:
        comm.barrier()



                    
##################### Note #############################
### Still for single exposure. Needs to be re-factored #
########################################################

if args.obstype in ['SCIENCE']:
    inputfile = findfile('raw', night=args.night, expid=args.expids[0])
    if not os.path.isfile(inputfile):
        raise IOError('Missing input file: {}'.format(inputfile))
    # - Fill in values from raw data header if not overridden by command line                
    fx = fitsio.FITS(inputfile)
    if 'SPEC' in fx:  # - 20200225 onwards                                            
        # hdr = fits.getheader(args.input, 'SPEC')                                         
        hdr = fx['SPEC'].read_header()
    elif 'SPS' in fx:  # - 20200224 and before                                                  
        # hdr = fits.getheader(args.input, 'SPS')                                                  
        hdr = fx['SPS'].read_header()
    else:
        # hdr = fits.getheader(args.input, 0)                                                                   
        hdr = fx[0].read_header()
        
    camhdr = dict()
    for cam in args.cameras:
        camhdr[cam] = fx[cam].read_header()

    fx.close()

    timer.start('stdstarfit')
    if rank == 0:
        log.info('Starting stdstar fitting at {}'.format(time.asctime()))
        
    # -------------------------------------------------------------------------
    # - Get input fiberflat
    input_fiberflat = dict()
    if rank == 0:
        for camera in args.cameras:
            if args.fiberflat is not None:
                input_fiberflat[camera] = args.fiberflat
            elif args.calibnight is not None:
                # look for a fiberflatnight for this calib night
                fiberflatnightfile = findfile('fiberflatnight',
                                              args.calibnight, args.expids[0], camera)
                if not os.path.isfile(fiberflatnightfile):
                    log.error("no {}".format(fiberflatnightfile))
                    raise IOError("no {}".format(fiberflatnightfile))
                input_fiberflat[camera] = fiberflatnightfile
            else:
                # look for a fiberflatnight fiberflat
                fiberflatnightfile = findfile('fiberflatnight',
                                              args.night, args.expids[0], camera)
            if os.path.isfile(fiberflatnightfile):
                    input_fiberflat[camera] = fiberflatnightfile
            elif args.most_recent_calib:
                # -- NOTE: Finding most recent only with respect to the first night
                nightfile = find_most_recent(args.night, file_type='fiberflatnight')
                if nightfile is None:
                    input_fiberflat[camera] = findcalibfile([hdr, camhdr[camera]], 'FIBERFLAT')
                else:
                    input_fiberflat[camera] = nightfile
            else:
                input_fiberflat[camera] = findcalibfile([hdr, camhdr[camera]], 'FIBERFLAT')
        log.info("Will use input FIBERFLAT: {}".format(input_fiberflat[camera]))

    if comm is not None:
        input_fiberflat = comm.bcast(input_fiberflat, root=0)

    # - Group inputs by spectrograph
    framefiles = dict()
    skyfiles = dict()
    fiberflatfiles = dict()
    for camera in args.cameras:
        sp = int(camera[1])
        if sp not in framefiles:
            framefiles[sp] = list()
            skyfiles[sp] = list()
            fiberflatfiles[sp] = list()

        for expid in args.expids:
            framefiles[sp].append(findfile('frame', args.night, expid, camera))
            skyfiles[sp].append(findfile('sky', args.night, expid, camera))
            fiberflatfiles[sp].append(input_fiberflat[camera])

    # - Hardcoded stdstar model version
    starmodels = os.path.join(
        os.getenv('DESI_BASIS_TEMPLATES'), 'stdstar_templates_v2.2.fits')

    # - Fit stdstars per spectrograph (not per-camera)
    spectro_nums = sorted(framefiles.keys())
    ## for sp in spectro_nums[rank::size]:
    for i in range(rank, len(spectro_nums), size):
        sp = spectro_nums[i]
        # - NOTE: Saving the joint fit file with only the name of the first exposure
        stdfile = findfile('stdstars', args.night, args.expids[0], spectrograph=sp)
        stdfile.replace('{:08d}'.format(args.expids[0]),'-'.join(['{:08d}'.format(eid) for eid in args.expids]))
        cmd = "desi_fit_stdstars"
        cmd += " --frames {}".format(' '.join(framefiles[sp]))
        cmd += " --skymodels {}".format(' '.join(skyfiles[sp]))
        cmd += " --fiberflats {}".format(' '.join(fiberflatfiles[sp]))
        cmd += " --starmodels {}".format(starmodels)
        cmd += " --outfile {}".format(stdfile)
        if args.maxstdstars is not None:
            cmd += " --maxstdstars {}".format(args.maxstdstars)

        inputs = framefiles[sp] + skyfiles[sp] + fiberflatfiles[sp]
        runcmd(cmd, inputs=inputs, outputs=[stdfile])

    timer.stop('stdstarfit')
    if comm is not None:
        comm.barrier()

# -------------------------------------------------------------------------
# - Wrap up

# if rank == 0:
#     report = timer.report()
#     log.info('Rank 0 timing report:\n' + report)

if comm is not None:
    timers = comm.gather(timer, root=0)
else:
    timers = [timer,]

if rank == 0:
    stats = desiutil.timer.compute_stats(timers)
    log.info('Timing summary statistics:\n' + json.dumps(stats, indent=2))

    if args.timingfile:
        if os.path.exists(args.timingfile):
            with open(args.timingfile) as fx:
                previous_stats = json.load(fx)

            #- augment previous_stats with new entries, but don't overwrite old
            for name in stats:
                if name not in previous_stats:
                    previous_stats[name] = stats[name]

            stats = previous_stats

        tmpfile = args.timingfile + '.tmp'
        with open(tmpfile, 'w') as fx:
            json.dump(stats, fx, indent=2)
        os.rename(tmpfile, args.timingfile)

if rank == 0:
    log.info('All done at {}'.format(time.asctime))
