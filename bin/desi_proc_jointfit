#!/usr/bin/env python


import time
from collections import OrderedDict

progress = OrderedDict(start=time.asctime())

import sys, os, argparse, re, time, collections
import subprocess
from copy import deepcopy

import numpy as np
import fitsio
from astropy.io import fits
import glob
import desispec.io
from desispec.io import findfile
from desispec.io.util import create_camword, find_most_recent
from desispec.calibfinder import findcalibfile,CalibFinder
from desispec.fiberflat import apply_fiberflat
from desispec.sky import subtract_sky
from desispec.util import runcmd
import desispec.scripts.extract
import desispec.scripts.specex

from desitarget.targetmask import desi_mask

from desiutil.log import get_logger, DEBUG, INFO







def get_desi_proc_jointfit_parser():
    """                                                                                                                             
    Create an argparser object to use to generate arguments from input data.                                                        
    """
    parser = argparse.ArgumentParser(usage = "{prog} [options]")
    parser.add_argument("-n", "--night", type=int,  help="YEARMMDD night")
    parser.add_argument("-e", "--expids", type=str,  help="Exposure ID")
    parser.add_argument("--obstype", type=str,  help="science, arc, flat, dark, zero, ...")
    parser.add_argument("--cameras", type=str,  help="Explicitly define the spectrographs for which you want"+
                                                     " to reduce the data. Should be a comma separated list."+
                                                     " Numbers only assumes you want to reduce R, B, and Z "+
                                                     "for that spectrograph. Otherwise specify separately [BRZ|brz][0-9].")
    parser.add_argument("--mpi", action="store_true", help="Use MPI parallelism")
    parser.add_argument('--maxstdstars', type=int, default=None, \
                        help='Maximum number of stdstars to include')
    parser.add_argument("--fiberflat",type=str,required=False,default=None, help="use this fiberflat")
    parser.add_argument("--calibnight",type=int,required=False,default=None, help="use this night to find nightly PSF and fiberflats")
    parser.add_argument("--batch", action="store_true", help="Submit a batch job to process this exposure")
    parser.add_argument("--nosubmit", action="store_true", help="Create batch script but don't submit")
    parser.add_argument("-q", "--queue", type=str, default="realtime", help="batch queue to use")
    parser.add_argument("--batch-opts", type=str, default=None, help="additional batch commands")
    parser.add_argument("--runtime", type=int, default=None,  help="batch runtime in minutes")

    return parser








parser = get_desi_proc_parser()
args = parser.parse_args()
log = get_logger()

#- Freeze IERS after parsing args so that it doesn't bother if only --help                                                          
import desiutil.iers
desiutil.iers.freeze_iers()


if args.mpi and not args.batch:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    rank = comm.rank
    size = comm.size
else:
    comm = None
    rank = 0
    size = 1

#- Prevent MPI from killing off spawned processes                                                                                   
if 'PMI_MMAP_SYNC_WAIT_TIME' not in os.environ:
    os.environ['PMI_MMAP_SYNC_WAIT_TIME'] = '3600'

#- Preflight checks                                                                                                                 
if rank > 0:
    #- Let rank 0 fetch these, and then broadcast                                                                                   
    args = None
else:
    cam_str = args.cameras.strip(' \t').lower()
    cameras = cam_str.split(',')
    if cam_str[0] not in ['b','r','z'] and cameras[0].isnumeric():
        args.cameras = []
        for camnum in cameras:
	    for ccd in ['b','r','z']:
                args.cameras.append('{}{}'.format(ccd,camnum))
    else:
        args.cameras = cameras

    args.expids = np.array(args.expids.strip(' \t').split(',')).astype(int)
    
    #- Update args to be in consistent format                                                                                                                                                            
    if args.batch_opts is not None:
        args.batch_opts = args.batch_opts.strip('"\'')
    args.cameras = sorted(args.cameras)
    args.obstype = args.obstype.upper()

if comm is not None:
    args = comm.bcast(args, root=0)

    
known_obstype = ['SCIENCE', 'ARC', 'FLAT']
if args.obstype not in known_obstype:
    raise RuntimeError('obstype {} not in {}'.format(args.obstype, known_obstype))


#-------------------------------------------------------------------------                                                          
#- Create and submit a batch job if requested                                                                                       

if args.batch:
    scriptfile = create_desi_proc_batch_script(args)
    err = 0
    if not args.nosubmit:
        err = subprocess.call(['sbatch', scriptfile])
    sys.exit(err)
    


    
#-------------------------------------------------------------------------                                                          
#- Proceed with running                                                                                                          

#- What are we going to do?                                                                                                         
if rank == 0:
    log.info('----------')
    log.info('Input {}'.format(args.input))
    log.info('Night {} expids {}'.format(args.night, args.expids))
    log.info('Obstype {}'.format(args.obstype))
    log.info('Cameras {}'.format(args.cameras))
    log.info('Output root {}'.format(desispec.io.specprod_root()))
    log.info('----------')

#- Wait for rank 0 to make directories before proceeding                                                                            
if comm is not None:
    comm.barrier()

if rank == 0:
    progress['init'] = time.asctime()


    
    
#-------------------------------------------------------------------------                                                          
#- Merge PSF of night if applicable                                                                                                 

if args.obstype in ['ARC']:                                                                                                        
    if rank == 0:
        for camera in args.cameras :
            psfnightfile = findfile('psfnight', args.night, args.expids[0], camera)
            if not os.path.isfile(psfnightfile) : # we still don't have a psf night, see if we can compute it ...                   
                psfs = [findfile('psf', args.night, expid, camera).replace("psf","fit-psf")) for expid in args.expids]
                log.info("Number of PSF for night={} camera={} = {}".format(args.night,camera,len(psfs)))
                if len(psfs)>4 : # lets do it!                                                                                      
                    log.info("Computing psfnight ...")
                    dirname=os.path.dirname(psfnightfile)
                    if not os.path.isdir(dirname) :
                        os.makedirs(dirname)
                    desispec.scripts.specex.mean_psf(psfs,psfnightfile)
                else:
                    log.info("Fewer than 4 psfs were provided, can't compute psfnight. Exiting ...")





#-------------------------------------------------------------------------                                                          
#- Average and auto-calib fiberflats of night if applicable                                                                         

if args.obstype in ['FLAT']:                                                                                                       
    if rank == 0:
        fiberflatnightfile = findfile('fiberflatnight', args.night, args.expids[0], args.cameras[0])
        fiberflatdirname=os.path.dirname(fiberflatnightfile)
        if os.path.isfile(fiberflatnightfile)
            log.info("Fiberflatnight already exists. Exitting ...")
        elif len(args.cameras)<6 : # we still don't have them, see if we can compute them
                                   #, but need at least 2 spectros ...
            log.info("Fewer than 6 cameras were available, so couldn't perform joint fit. Exiting ...")
        else:
            flats = []
            for camera in args.cameras:
                for expid in args.expids:
                    flats.append(findfile('fiberflat', args.night, expid, camera))
            log.info("Number of fiberflat for night {} = {}".format(args.night,len(flats)))
            if len(flats)<3*4*len(args.cameras) :
                log.info("Fewer than 3 exposures with 4 lamps were available. Can't perform joint fit. Exiting...")
            else:
                log.info("Computing fiberflatnight per lamp and camera ...")
                tmpdir=os.path.join(fiberflatdirname,"tmp")
                if not os.path.isdir(tmpdir) :
                    os.makedirs(tmpdir)

                log.info("First average measurements per camera and per lamp")
                average_flats=dict()
                for camera in args.cameras :
                    # list of flats for this camera                                                                                 
                    flats_for_this_camera=[]
                    for flat in flats :
                        if flat.find(camera)>=0 :
                            flats_for_this_camera.append(flat)
                    #log.info("For camera {} , flats = {}".format(camera,flats_for_this_camera))                                    
                    #sys.exit(12)                                                                                                   

                    # average per lamp (and camera)                                                                                 
                    average_flats[camera] = list()
                    for lampbox in range(4) :
                        ofile=os.path.join(tmpdir,"fiberflatnight-camera-{}-lamp-{}.fits".format(camera,lampbox))
                        if not os.path.isfile(ofile) :
                            log.info("Average flat for camera {} and lamp box #{}".format(camera,lampbox))
                            pg="CALIB DESI-CALIB-0{} LEDs only".format(lampbox)

                            cmd="desi_average_fiberflat --program '{}' --outfile {} -i ".format(pg,ofile)
                            for flat in flats_for_this_camera :
                                cmd += " {} ".format(flat)
                            runcmd(cmd, inputs=flats_for_this_camera, outputs=[ofile,])
                            if os.path.isfile(ofile) :
                                average_flats[camera].append(ofile)
                        else :
                            log.info("Will use existing {}".format(ofile))
                            average_flats[camera].append(ofile)

                log.info("Auto-calibration across lamps and spectro  per camera arm (b,r,z)")
                for camera_arm in ["b","r","z"] :
                    cameras_for_this_arm = []
                    flats_for_this_arm = []
                    for camera in args.cameras :
                        if camera[0].lower() == camera_arm :
                            cameras_for_this_arm.append(camera)
                            if camera in average_flats :
                                 for flat in average_flats[camera] :
                                     flats_for_this_arm.append(flat)
                    cmd="desi_autocalib_fiberflat --night {} --arm {} -i ".format(args.night,camera_arm)
                    for flat in flats_for_this_arm :
                        cmd += " {} ".format(flat)
                    runcmd(cmd, inputs=flats_for_this_arm, outputs=[])
                log.info("Done with fiber flats per night")


    if comm is not None:
        comm.barrier()




##################### Note #############################
### Still for single exposure. Needs to be re-factored #
########################################################
if args.obstype in ['SCIENCE']:
    if rank == 0:
        log.info('Starting flux calibration at {}'.format(time.asctime()))

    #-------------------------------------------------------------------------                                                          
    #- Get input fiberflat                                                                                                              
    input_fiberflat = dict()
    if rank == 0:
        for camera in args.cameras :
            if args.fiberflat is not None :
                input_fiberflat[camera] = args.fiberflat
            elif args.calibnight is not None :
                # look for a fiberflatnight for this calib night                                                                        
                fiberflatnightfile = findfile('fiberflatnight',
                                              args.calibnight, args.expids[0], camera)
                if not os.path.isfile(fiberflatnightfile) :
                    log.error("no {}".format(fiberflatnightfile))
                    raise IOError("no {}".format(fiberflatnightfile))
                input_fiberflat[camera] = fiberflatnightfile
            else :
                # look for a fiberflatnight fiberflat                                                                                   
                fiberflatnightfile = findfile('fiberflatnight',
                                              args.night, args.expids[0], camera)
                if os.path.isfile(fiberflatnightfile) :
		    input_fiberflat[camera] = fiberflatnightfile
                elif args.most_recent_calib:
                    nightfile = find_most_recent(args.night, file_type='fiberflatnight')
                    if nightfile is None:
                        input_fiberflat[camera] = findcalibfile([hdr, camhdr[camera]], 'FIBERFLAT')
                    else:
                        input_fiberflat[camera] = nightfile
                else :
                    input_fiberflat[camera] = findcalibfile(
                        [hdr, camhdr[camera]], 'FIBERFLAT')
            log.info("Will use input FIBERFLAT: {}".format(input_fiberflat[camera]))

    if comm is not None:
        input_fiberflat = comm.bcast(input_fiberflat, root=0)
    
    #- Group inputs by spectrograph                                                                                                 
    framefiles = dict()
    skyfiles = dict()
    fiberflatfiles = dict()
    night = args.night                                                                                
    for camera in args.cameras:
        sp = int(camera[1])
        if sp not in framefiles:
            framefiles[sp] = list()
            skyfiles[sp] = list()
            fiberflatfiles[sp] = list()

        for expid in args.expids:
            framefiles[sp].append(findfile('frame', night, expid, camera))
            skyfiles[sp].append(findfile('sky', night, expid, camera))
            fiberflatfiles[sp].append(input_fiberflat[camera])

    #- Hardcoded stdstar model version                                                                                              
    starmodels = os.path.join(
            os.getenv('DESI_BASIS_TEMPLATES'), 'stdstar_templates_v2.2.fits')

    #- Fit stdstars per spectrograph (not per-camera)                                                                               
    spectro_nums = sorted(framefiles.keys())
    ## for sp in spectro_nums[rank::size]:                                                                                          
    for i in range(rank, len(spectro_nums), size):
        sp = spectro_nums[i]

        stdfile = findfile('stdstars', night, expid, spectrograph=sp)
        cmd = "desi_fit_stdstars"
        cmd += " --frames {}".format(' '.join(framefiles[sp]))
        cmd += " --skymodels {}".format(' '.join(skyfiles[sp]))
        cmd += " --fiberflats {}".format(' '.join(fiberflatfiles[sp]))
        cmd += " --starmodels {}".format(starmodels)
        cmd += " --outfile {}".format(stdfile)
        if args.maxstdstars is not None:
            cmd += " --maxstdstars {}".format(args.maxstdstars)

        inputs = framefiles[sp] + skyfiles[sp] + fiberflatfiles[sp]
        runcmd(cmd, inputs=inputs, outputs=[stdfile])

    if comm is not None:
        comm.barrier()

#-------------------------------------------------------------------------                                                          
#- Wrap up                                                                                                                          

if rank == 0:
    progress['done'] = time.asctime()

    t0 = None
    print('\nSummary of completion times:')
    for key, value in progress.items():
        if t0 is None:
            print('  {:10s} {}'.format(key, value))
            t0 = time.mktime(time.strptime(value))
        else:
            t1 = time.mktime(time.strptime(value))
            dt = (t1-t0)/60.0
            t0 = t1
            print('  {:10s} {} ({:.1f} min)'.format(key, value, dt))
